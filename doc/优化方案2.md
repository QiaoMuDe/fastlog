# 字段日志功能优化方案

## 核心优化建议

1. **与现有日志格式集成**
   - 完全复用现有的日志格式配置，不需要额外的配置项
   - 根据当前日志格式自动调整字段输出格式，保持一致性

2. **性能优化**
   - 使用对象池减少内存分配
   - 预分配缓冲区容量
   - 使用 `sync.Pool` 复用 `FieldLogger` 对象

3. **API 增强**
   - 支持更多数据类型的字段值
   - 提供更灵活的链式调用
   - 添加批量添加字段的方法

4. **集成现有日志系统**
   - 保持与现有日志级别和格式一致
   - 复用现有的 `processLog` 方法

## 字段格式与日志格式对应关系

根据不同的日志格式，字段日志会自动调整输出格式：

1. **Detailed 格式**：字段作为消息的一部分，放在消息后面
   ```
   2025-01-15 10:30:45 | INFO    | main.go:main:15 - 用户登录成功 user_id=12345 action=login ip=192.168.1.1
   ```

2. **JSON 格式**：字段作为JSON对象的额外属性
   ```json
   {"time":"2025-01-15 10:30:45","level":"INFO","file":"main.go","function":"main","line":15,"message":"用户登录成功","user_id":12345,"action":"login","ip":"192.168.1.1"}
   ```

3. **JsonSimple 格式**：同样作为JSON对象的额外属性
   ```json
   {"time":"2025-01-15 10:30:45","level":"INFO","message":"用户登录成功","user_id":12345,"action":"login","ip":"192.168.1.1"}
   ```

4. **Simple 格式**：字段作为消息的一部分
   ```
   2025-01-15 10:30:45 | INFO    | 用户登录成功 user_id=12345 action=login ip=192.168.1.1
   ```

5. **Structured 格式**：字段作为额外的结构化字段，使用冒号分隔键值对
   ```
   T:2025-01-15 10:30:45|L:INFO   |F:main.go:main:15|M:用户登录成功|user_id:12345|action:login|ip:192.168.1.1
   ```

6. **BasicStructured 格式**：字段作为额外的结构化字段，使用冒号分隔键值对
   ```
   T:2025-01-15 10:30:45|L:INFO   |M:用户登录成功|user_id:12345|action:login|ip:192.168.1.1
   ```

7. **SimpleTimestamp 格式**：字段作为消息的一部分
   ```
   2025-01-15 10:30:45 INFO  用户登录成功 user_id=12345 action=login ip=192.168.1.1
   ```

## 具体实现代码

```go
// FieldLogger 字段日志构建器
type FieldLogger struct {
    logger *FastLog
    level  LogLevel
    fields map[string]interface{}
    buffer *bytes.Buffer // 复用缓冲区提高性能
}

// 使用对象池管理 FieldLogger 实例
var fieldLoggerPool = sync.Pool{
    New: func() interface{} {
        return &FieldLogger{
            fields: make(map[string]interface{}),
            buffer: bytes.NewBuffer(make([]byte, 0, 256)), // 预分配缓冲区
        }
    },
}

// WithFields 创建一个字段日志构建器
func (f *FastLog) WithFields(level LogLevel) *FieldLogger {
    fl := fieldLoggerPool.Get().(*FieldLogger)
    fl.logger = f
    fl.level = level
    // 清空之前可能存在的字段
    for k := range fl.fields {
        delete(fl.fields, k)
    }
    fl.buffer.Reset()
    return fl
}

// AddField 添加字段，支持链式调用
func (fl *FieldLogger) AddField(key string, value interface{}) *FieldLogger {
    if fl != nil && fl.fields != nil {
        fl.fields[key] = value
    }
    return fl
}

// AddFields 批量添加多个字段
func (fl *FieldLogger) AddFields(fields map[string]interface{}) *FieldLogger {
    if fl != nil && fl.fields != nil && fields != nil {
        for k, v := range fields {
            fl.fields[k] = v
        }
    }
    return fl
}

// Log 输出日志
func (fl *FieldLogger) Log(message string) {
    if fl == nil || fl.logger == nil || fl.fields == nil {
        return
    }
    
    // 对于JSON格式，需要特殊处理
    if fl.logger.config.LogFormat == Json || fl.logger.config.LogFormat == JsonSimple {
        // 创建一个临时的日志消息对象
        logMsg := getLogMsg()
        defer putLogMsg(logMsg)
        
        // 填充基本信息
        logMsg.Timestamp = getCachedTimestamp()
        logMsg.Level = fl.level
        logMsg.Message = message
        
        // 如果需要文件信息
        if needsFileInfo(fl.logger.config.LogFormat) {
            fileName, funcName, line, ok := getCallerInfo(3)
            if ok {
                logMsg.FileName = fileName
                logMsg.FuncName = funcName
                logMsg.Line = line
            }
        }
        
        // 将字段添加到日志消息中
        for k, v := range fl.fields {
            // 使用反射动态添加字段
            reflect.ValueOf(logMsg).Elem().FieldByName(k).Set(reflect.ValueOf(v))
        }
        
        // 序列化为JSON并输出
        jsonBytes, _ := json.Marshal(logMsg)
        fl.logger.writeLog(string(jsonBytes))
    } else {
        // 非JSON格式，格式化字段信息
        formattedFields := fl.formatFields()
        
        // 根据字段是否为空决定是否添加空格
        finalMessage := message
        if formattedFields != "" {
            finalMessage = message + " " + formattedFields
        }
        
        // 调用现有日志处理流程
        fl.logger.processLog(fl.level, finalMessage)
    }
    
    // 回收对象到池
    fieldLoggerPool.Put(fl)
}

// formatFields 根据当前日志格式类型格式化字段
func (fl *FieldLogger) formatFields() string {
    if len(fl.fields) == 0 {
        return ""
    }
    
    fl.buffer.Reset()
    
    // 根据当前日志格式决定字段格式
    switch fl.logger.config.LogFormat {
    case Json, JsonSimple:
        // JSON格式 - 这种情况在Log方法中特殊处理，这里不需要实现
        return ""
        
    case Structured, BasicStructured:
        // 结构化格式，使用冒号和竖线分隔
        first := true
        for key, value := range fl.fields {
            if !first {
                fl.buffer.WriteString("|")
            } else {
                first = false
            }
            fl.buffer.WriteString(key)
            fl.buffer.WriteString(":")
            fmt.Fprintf(fl.buffer, "%v", value)
        }
        
    default:
        // 默认键值对格式
        first := true
        for key, value := range fl.fields {
            if !first {
                fl.buffer.WriteString(" ")
            } else {
                first = false
            }
            fl.buffer.WriteString(key)
            fl.buffer.WriteString("=")
            fmt.Fprintf(fl.buffer, "%v", value)
        }
    }
    
    return fl.buffer.String()
}
```

## 使用示例

```go
// 创建日志实例
logger := fastlog.NewFastLog(config)

// 使用字段日志
logger.WithFields(fastlog.INFO).
    AddField("user_id", 12345).
    AddField("action", "login").
    AddField("ip", "192.168.1.1").
    Log("用户登录成功")

// 批量添加字段
logger.WithFields(fastlog.DEBUG).
    AddFields(map[string]interface{}{
        "request_id": "abc-123",
        "duration_ms": 42,
        "status_code": 200,
    }).
    Log("API请求完成")
```

## 实现步骤

1. 在 `internal.go` 中添加 `FieldLogger` 结构体及相关方法
2. 在 `fastlog.go` 中为 `FastLog` 添加 `WithFields` 方法
3. 添加测试用例验证功能
4. 更新文档说明

## 优势

1. **一致性**：字段日志与现有日志格式保持一致，提供统一的用户体验
2. **高性能**：通过对象池和预分配缓冲区，减少内存分配和GC压力
3. **易用性**：提供简洁的API，支持链式调用和批量添加字段
4. **灵活性**：根据不同的日志格式自动调整字段输出格式
5. **无侵入性**：不破坏现有API，保持向后兼容性