# Fastlog代码重构与日志轮转


你的问题非常关键！在高并发环境下，频繁地获取和释放锁确实可能会对性能产生影响。锁操作本身是有开销的，尤其是在高并发场景下，多个 Goroutine 争抢锁会导致上下文切换和等待时间增加，从而降低程序的整体性能。

锁的性能问题

1. 锁的开销：每次获取和释放锁都需要进行同步操作，这会消耗 CPU 时间。
2. 锁竞争：当多个 Goroutine 同时尝试获取锁时，会导致其他 Goroutine 阻塞，增加等待时间。
3. 上下文切换：频繁的锁操作可能导致 Goroutine 之间的上下文切换，进一步降低性能。

优化锁的使用

为了避免频繁锁操作带来的性能问题，可以采用以下优化策略：

1.减少锁的粒度

尽量减少锁的范围，只在必要的代码块中使用锁。例如，只在日志轮转时获取锁，而在正常的日志写入时尽量避免锁操作。

2.使用缓冲日志

引入一个缓冲区（如 `chan []byte`或 `sync.Pool`），将日志消息暂存起来，然后由一个单独的 Goroutine 负责批量写入日志文件。这样可以减少锁的使用频率，同时提高写入效率。

3.使用无锁数据结构

在某些场景下，可以使用无锁数据结构（如环形缓冲区）来暂存日志消息，减少锁的使用。

4.异步日志写入

将日志写入操作异步化，由一个专门的日志 Goroutine 负责处理日志写入和轮转操作。这样可以避免多个 Goroutine 同时操作文件句柄。

优化后的实现

以下是一个优化后的日志轮转模块实现，使用异步写入和缓冲机制来减少锁的使用：

1.定义日志轮转结构体

```go

package main


import (

	"bufio"

	"fmt"

	"os"

	"path/filepath"

	"sync"

	"time"

)


type LogRotator struct {

	logFilePath string

	maxSize     int64

	keepDays    int

	writer      *bufio.Writer

	file        *os.File

	mu          sync.Mutex

	logChan     chan []byte

	stop        chan struct{}

}


func NewLogRotator(logFilePath string, maxSize int64, keepDays int) *LogRotator {

	return &LogRotator{

		logFilePath: logFilePath,

		maxSize:     maxSize,

		keepDays:    keepDays,

		logChan:     make(chan []byte, 1000), // 缓冲区大小

		stop:        make(chan struct{}),

	}

}

```

2.启动日志写入 Goroutine

```go

func (lr *LogRotator) Start() {

	go lr.run()

}


func (lr *LogRotator) run() {

	for {

		select {

		case logEntry := <-lr.logChan:

			lr.mu.Lock()

			_, err := lr.writer.Write(logEntry)

			if err != nil {

				fmt.Println("Failed to write log:", err)

			}

			lr.writer.Flush()

			lr.checkRotation()

			lr.mu.Unlock()

		case <-lr.stop:

			return

		}

	}

}

```

3.写入日志

```go

func (lr *LogRotator) Write(p []byte) (n int, err error) {

	select {

	case lr.logChan <- p:

		return len(p), nil

	default:

		return 0, fmt.Errorf("log buffer is full")

	}

}

```

4.检查轮转条件

```go

func (lr *LogRotator) checkRotation() {

	fileInfo, _ := lr.file.Stat()

	if fileInfo.Size() >= lr.maxSize {

		lr.rotate()

	}

}


func (lr *LogRotator) rotate() {

	lr.file.Close()

	newFilePath := fmt.Sprintf("%s.%s", lr.logFilePath, time.Now().Format("20060102150405"))

	os.Rename(lr.logFilePath, newFilePath)

	lr.file, _ = os.OpenFile(lr.logFilePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)

	lr.writer = bufio.NewWriter(lr.file)

}

```

5.清理旧日志

```go

func (lr *LogRotator) cleanOldLogs() {

	logDir := filepath.Dir(lr.logFilePath)

	files, _ := filepath.Glob(filepath.Join(logDir, "*.log.*"))

	for _, file := range files {

		fileInfo, _ := os.Stat(file)

		if time.Since(fileInfo.ModTime()) > time.Duration(lr.keepDays)*24*time.Hour {

			os.Remove(file)

		}

	}

}

```

6.停止日志轮转

```go

func (lr *LogRotator) Stop() {

	close(lr.stop)

	lr.file.Close()

}

```

7.主函数

```go

func main() {

	logRotator := NewLogRotator("./logs/app.log", 1024*1024*10, 7)

	logRotator.Start()


	// 模拟高并发日志写入

	var wg sync.WaitGroup

	for i := 0; i < 100; i++ {

		wg.Add(1)

		go func() {

			defer wg.Done()

			for j := 0; j < 1000; j++ {

				logRotator.Write([]byte(fmt.Sprintf("Log entry %d\n", j)))

			}

		}()

	}

	wg.Wait()

	logRotator.Stop()

}

```

优化后的原理总结

1. 异步写入：通过一个独立的 Goroutine 负责日志写入和轮转操作，减少锁的使用频率。
2. 缓冲机制：使用缓冲区暂存日志消息，批量写入文件，减少 I/O 操作。
3. 锁的范围最小化：只在必要的代码块（如轮转操作）中使用锁，减少锁的粒度。
4. 资源管理：在轮转时关闭旧文件句柄并打开新文件句柄，确保资源的正确管理。

通过上述优化，可以显著减少锁的使用频率，提高日志系统的性能和并发能力。
