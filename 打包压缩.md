根据你的需求，实现日志压缩的逻辑时，可以考虑以下两种方案：
方案1：先重命名，再压缩，最后删除源文件
这种方案的步骤如下：
重命名：将需要压缩的日志文件重命名为一个临时文件名（例如添加 .tmp 后缀）。
压缩：对重命名后的文件进行压缩。
删除源文件：压缩完成后，删除原始的日志文件。
这种方法的优点是操作过程清晰，且在压缩过程中不会影响到正在使用的日志文件。缺点是需要额外的磁盘空间来存储临时文件。
方案2：直接压缩并删除源文件
这种方案的步骤如下：
压缩：直接对原始日志文件进行压缩。
删除源文件：压缩完成后，删除原始的日志文件。
这种方法的优点是操作简单，不需要额外的磁盘空间来存储临时文件。缺点是在压缩过程中可能会对正在使用的日志文件产生影响，尤其是在多进程或高并发的场景下。
推荐方案
基于上述两种方案的优缺点，我推荐使用 方案1，即先重命名，再压缩，最后删除源文件。这种方式更加安全，避免了在压缩过程中对正在使用的日志文件产生影响。
示例代码
以下是一个基于 方案1 的日志压缩逻辑的示例代码：
go复制
package main

import (
	"archive/tar"
	"compress/gzip"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"time"
)

type Logger struct {
	logDirName        string
	logFilePath       string
	logRetentionDays  int
	logRetentionCount int
	compressionFormat string // 支持 "gz"、"zip" 等
}

func (l *Logger) compressLogFile(filePath string) error {
	// 1. 重命名原始日志文件为临时文件
	tmpFilePath := filePath + ".tmp"
	if err := os.Rename(filePath, tmpFilePath); err != nil {
		return fmt.Errorf("重命名日志文件失败: %w", err)
	}

    // 2. 压缩临时文件
	compressedFilePath := filePath + ".gz"
	fileToCompress, err := os.Open(tmpFilePath)
	if err != nil {
		return fmt.Errorf("打开临时文件失败: %w", err)
	}
	defer fileToCompress.Close()

    compressedFile, err := os.Create(compressedFilePath)
	if err != nil {
		return fmt.Errorf("创建压缩文件失败: %w", err)
	}
	defer compressedFile.Close()

    gzipWriter := gzip.NewWriter(compressedFile)
	defer gzipWriter.Close()

    tarWriter := tar.NewWriter(gzipWriter)
	defer tarWriter.Close()

    header := &tar.Header{
		Name: filePath,
		Size: int64(fileToCompress.Size()),
		Mode: 0644,
	}
	if err := tarWriter.WriteHeader(header); err != nil {
		return fmt.Errorf("写入tar头失败: %w", err)
	}

    if _, err := io.Copy(tarWriter, fileToCompress); err != nil {
		return fmt.Errorf("复制文件内容到tar失败: %w", err)
	}

    // 3. 删除临时文件
	if err := os.Remove(tmpFilePath); err != nil {
		return fmt.Errorf("删除临时文件失败: %w", err)
	}

    fmt.Printf("日志文件已压缩为: %s\n", compressedFilePath)
	return nil
}

func (l *Logger) logFileClean() error {
	files, err := os.ReadDir(l.logDirName)
	if err != nil {
		return fmt.Errorf("无法读取日志目录: %w", err)
	}

    for _, file := range files {
		if file.IsDir() {
			continue
		}
		if filepath.Ext(file.Name()) == ".log" {
			filePath := filepath.Join(l.logDirName, file.Name())
			if filePath == l.logFilePath {
				// 跳过当前正在写入的日志文件
				continue
			}
			if err := l.compressLogFile(filePath); err != nil {
				fmt.Printf("压缩日志文件失败: %s, 错误: %v\n", filePath, err)
			}
		}
	}
	return nil
}

func main() {
	logger := Logger{
		logDirName:        "./logs",
		logFilePath:       "./logs/app.log",
		logRetentionDays:  7,
		logRetentionCount: 3,
		compressionFormat: "gz",
	}
	if err := logger.logFileClean(); err != nil {
		fmt.Printf("日志清理失败: %v\n", err)
	}
}
代码说明
重命名：将原始日志文件重命名为临时文件，避免在压缩过程中影响到正在使用的日志文件。
压缩：使用 gzip 和 tar 对临时文件进行压缩。
删除临时文件：压缩完成后，删除临时文件。
这种方法确保了日志压缩过程的安全性和可靠性，同时避免了对正在使用的日志文件产生影响。
